# 模块边界与契约

## 0. 总则（强约束）

- **依赖方向必须单向**：高层编排依赖低层能力；低层不得反向引用高层。
- **实现不可当契约**：`*Basic/*Runtime/*UdpPeer` 这类实现类型不得成为跨模块依赖的“事实标准”。
- **契约必须可测试**：对外暴露的接口与数据格式必须能在不启动 SDL/窗口的情况下被测试覆盖。

## 1. 依赖与分层（目标形态）

> 说明：这是“应该长成什么样”的契约，允许当前实现未完全达成，但任何新增代码必须向该方向收敛。

- `core`：基础工具与稳定配置（日志、配置、常量、通用小工具）。
- `platform`：窗口/输入/渲染后端封装（SDL3 等），只处理平台细节。
- `world`：权威世界数据与快照（chunk/tile），对外只暴露接口与快照编解码。
- `net`：会话与传输层（握手/心跳/收发队列/诊断），不理解玩法语义。
- `script`：脚本运行时与沙箱（LuaJIT 等），通过事件总线与主循环交互。
- `mod`：模组清单与内容定义装载（manifest/content），不耦合渲染与网络。
- `save`：存档持久化（版本化、回滚），默认不做旧版本兼容，不耦合窗口与输入。
- `sim`：固定 Tick 的仿真调度与跨模块协同（权威/副本模式），不包含 UI/平台细节。
- `runtime`：运行期装配与跨模块管线（mod 加载、存档加载、指纹策略、世界服务工厂），面向 app/tools 提供可测试的组合入口，不引入平台/UI。
- `app`：把上述模块装配成可运行产品（启动、主循环、输入到命令的映射、渲染场景构建）。
- `tools`：调试/压测/打包等辅助可执行（应复用 `src` 的库代码，不复制逻辑）。
- `tests`：自动化验证（优先覆盖契约与跨模块链路）。

## 2. 模块契约

### 2.1 `core`

**职责**

- 提供可复用的基础设施：日志、配置解析、稳定常量与小工具。

**禁止**

- 不得依赖 `SDL`、网络 socket、文件系统的业务目录结构（例如 `mods/`、`saves/` 的策略应在更高层决定）。

### 2.2 `platform`

**职责**

- 把平台细节封装为稳定输入与渲染接口：
  - 输入：输出 `platform::InputActions`（原始动作信号 + 光标/视口信息）。
  - 渲染：消费 `platform::RenderScene`（已准备好的渲染数据，不再回查 world）。

**禁止（关键）**

- 不得 include `world/*Basic*` 或读取 world 数据结构。
- 不得包含玩法判断（例如“材料是否可采集/是否遮光/颜色映射”）。

### 2.3 `world`

**职责**

- 维护权威世界数据与快照：
  - `world::IWorldService`：Tile/Chunk 读写、加载/卸载、脏块追踪、快照构建与应用。
  - `world::WorldSnapshotCodec`：快照编解码（需要版本化；默认不做跨版本兼容）。
- 提供材料碰撞形状元数据（`CollisionShape`），支撑连续运动与斜坡/半砖表达。

**对外保证**

- `ConsumeDirtyChunks()` 的输出必须稳定且可复现（用于网络与存档一致性）。

**禁止**

- 不得依赖 `net`、`script`、`platform`。

### 2.4 `net`

**职责**

- 只负责“会话 + 传输 + 队列 + 诊断”：
  - `INetService` 作为仿真层的唯一入口。
  - 不理解 `command_id` 对应的玩法语义，不参与规则判断。

**对外保证**

- 诊断指标语义必须一致（`dropped` 只表示真实丢弃；“未发送到远端”必须单列）。
- 收发队列必须有上限与可观测性（丢弃原因可追溯）。

**禁止**

- 不得依赖 `world` 的实现细节（快照 payload 只当作字节/文本负载）。

### 2.5 `script`

**职责**

- 提供脚本宿主与沙箱：
  - `IScriptHost::Tick`：在固定 Tick 中调用脚本回调。
  - `IScriptHost::DispatchEvent`：接收事件并在脚本端消费。
  - `RuntimeDescriptor`：暴露可观测元信息（后端名、API 版本、沙箱级别、配额）。

**对外保证**

- API 版本必须严格校验（不匹配 fail-fast）。
- capability 白名单必须明确，越权 fail-fast。

**禁止（关键）**

- 脚本不得直接调用渲染/网络底层；脚本只通过事件与受控回调表达行为。

### 2.6 `mod`

**职责**

- 扫描 `mod.cfg` 并装载可选内容定义（items/recipes/npcs）与脚本元信息。
- 构建稳定指纹，用于联机一致性与存档校验。

**对外保证**

- 指纹算法必须稳定、可复现、碰撞风险可控（建议使用 SHA-256）。
- 依赖拓扑排序稳定；缺失依赖与循环依赖必须明确报错。

### 2.7 `save`

**职责**

- 以版本化格式持久化世界状态、玩法进度与诊断快照。
- 提供回滚与原子写入策略，避免存档损坏。

**对外保证**

- 兼容策略明确：不兼容旧版、前向版本拒绝、字段缺省语义稳定。

**禁止**

- 不得依赖 `platform/app`。

### 2.8 `sim`

**职责**

- 固定 Tick 的仿真调度与跨模块协同：
  - 输入：来自 `net` 的命令与来自 `app` 的本地命令注入。
  - 输出：对 `world` 的变更、对 `net` 的快照发布、对 `script` 的事件分发。
- 连续角色运动与碰撞处理，消费 `world` 的 `CollisionShape`。

**对外保证**

- Tick 顺序固定且可复盘（详见 `docs/architecture/simulation-pipeline.md`）。
- 权威模式与副本模式行为可预测，且差异清晰。

**禁止（关键）**

- `sim` 不得依赖 SDL/窗口/文件系统路径策略。
- `SimulationKernel` 不得成为玩法规则大杂烩：规则应拆为 system/ruleset（可渐进式落地）。

### 2.9 `runtime`

**职责**

- 提供跨模块装配管线与策略封装：mod/脚本加载、存档加载与回放、指纹策略与世界服务工厂等。
- 输出面向 `app/tools` 的可测试组合入口，减少启动/装配重复逻辑。
**对外保证**

- 组合入口不创建长期全局状态；仅返回结果/错误与必要数据。
- 失败路径可诊断：通过返回值与错误字符串明示，不静默吞错。
**禁止**

- 不得依赖 `app/platform`（不接触 SDL/窗口/输入/渲染）。
- 不得承载玩法规则与持久状态（规则应留在 `sim/mod/save` 等模块内）。
### 2.10 `app`

**职责**

- 负责装配与编排（启动、主循环、输入到命令映射、渲染场景构建、退出与存档）。

**对外保证**

- `app` 与 `platform` 只通过稳定数据结构交互（`InputActions/RenderScene`）。
- `app` 不得依赖 `world` 的具体实现类型；只依赖接口与稳定材料/渲染元信息。

### 2.11 `tools`

**职责**

- 提供联调、压测、打包脚本与独立服务端。

**强约束**

- 禁止复制 `src` 的业务逻辑：工具必须复用库代码；任何复制都要在下一次重构中消除。
